#!/usr/bin/env node
var ncp = require('ncp').ncp;
var jsonfile = require('jsonfile');
var os = require('os');
var fs = require('fs');
var path = require('path');
var { exec } = require('child_process');
let packageName = process.argv[2];
function createPackageDirIfNotExist(packageName) {
    try {
        fs.mkdirSync(packageName);
    }
    catch (err) {
        console.error(`There's already a folder with the package name "${packageName}" in this directory. Aborting.`);
        process.exit(-1);
    }
    return path.join(process.cwd(), packageName);
}
const errorHandler = (command, err, stdout, stderr) => {
    if (err) {
        // node couldn't execute the command
        console.error(`failed while running command ${command}:`, err);
        return;
    }
    console.log(stdout);
    if (stderr) {
        console.error(`stderr: ${stderr}`);
    }
};
const packageDir = createPackageDirIfNotExist(packageName);
ncp.limit = 16;
ncp(path.join(__dirname, '../blueprint/'), packageDir, (err) => {
    if (err)
        return console.error(err);
    // Replace the package name and author name
    let packageFilePath = path.join(packageDir, '/package.json');
    console.log(packageFilePath);
    let username = '';
    try {
        username = os.userInfo().username;
    }
    catch (error) {
        console.error('Error getting Windows username, using blank username');
    }
    let packageJsonContents = jsonfile.readFileSync(packageFilePath);
    packageJsonContents.name = packageName;
    packageJsonContents.author = username;
    let binField = {};
    binField[packageName] = "./build/main.js";
    packageJsonContents.bin = binField;
    jsonfile.writeFileSync(packageFilePath, packageJsonContents, { spaces: 2 });
    console.log(`Package name = "${packageName}", author = "${username}"`);
    console.log('Running git init...');
    let command = `git init ./${packageName}`;
    exec(command, (err, stdout, stderr) => errorHandler(command, err, stdout, stderr));
    // Create a .gitignore file with default contents
    const gitIgnoreContents = `# Ignore node_modules anywhere in the directory tree
**/node_modules/
# Ignore the outputs of tsc
/build/
# Ignore the code coverage reports generated by jest+istanbul (nyc):
/coverage`;
    fs.writeFileSync(`./${packageName}/.gitignore`, gitIgnoreContents);
    // Insert the package name into the README file
    const deployedReadmeFile = `./${packageName}/README.md`;
    let readmeContents = fs.readFileSync(deployedReadmeFile, 'utf8');
    let newReadmeContents = readmeContents.replace(/my-new-project/gi, packageName);
    fs.writeFileSync(deployedReadmeFile, newReadmeContents);
    // Run npm commands to install the dependencies
    const devDependencies = [
        '@types/node',
        'typescript',
        'ts-node',
        'jest',
        'ts-jest',
        '@types/jest',
    ].join(' ');
    console.log('Running npm install...');
    command = `npm i -D ${devDependencies}`;
    const configToUseRepoDir = { cwd: path.resolve(`./${packageName}`) };
    exec(command, configToUseRepoDir, (err, stdout, stderr) => {
        errorHandler(command, err, stdout, stderr);
        // Run a command to initialize a ts-jest config file which will tell
        // jest to precompile test.ts files
        console.log('Running ts-jest config:init...');
        command = `npx ts-jest config:init`;
        exec(command, configToUseRepoDir, (err, stdout, stderr) => errorHandler(command, err, stdout, stderr));
        errorHandler(command, err, stdout, stderr);
    });
});
